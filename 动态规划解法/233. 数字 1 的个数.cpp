/*
233. 数字 1 的个数
给定一个整数 n，计算所有小于等于 n 的非负整数中数字 1 出现的个数。

 

示例 1：

输入：n = 13
输出：6
示例 2：

输入：n = 0
输出：0
 

提示：

0 <= n <= 109
*/

/*
解题：
题目要我们记录1~n里每个数字里出现的1的个数的加和。

列出1~n中的每一个数字：

1, 2......n

经过简单思考,我们可以算出1~n中每一位数字中1的数量的加和

从个位数开始,固定住个位是1,假设 n = 21012, 有：

0 1
1 1
2 1
.....
2101 1

可见个位数是1的数字一共有2102个，即0~2101的个数

在考虑十位数是1的个数，把十位数固定成1，暂且把个位数固定成0有：

010
110
210
......
21010

一共有211个，即0~210个，实际上，个位数在0 ~ 209中有0 ~ 9 ->10种取法，而在210时仅有0 ~ 2 -> 3种取法

即实际取法有：210 * 10 + 1 * 3

对于百位是1，十位和个位都暂定为0有：

0100

1100

2100

......
20100

一共有21个，即0~20，由于此位是0，所以前两位无法取到21，至于个位和十位，一共有0~99 ->100种取法
即实际取法有： 21 * 100
即对于每一位数字，我们记录下这个位置前面的数字和这个位置后面的数字，即可算出最后的总和
*/

int countDigitOne(int n)
{
    long long i = 1; // 记录到第几位
    int before = 0; // befor身后的数字
    long long ans = 0; // 和
    while (n) {
        int temp = n % 10;
        n /= 10;
        if (temp > 1) {
            ans += (n + 1) * i;
        } else if (temp == 1) {
            ans += (n * i) + before + 1;
        } else {
            ans += (n * i);
        }
        before += temp * i;
        i *= 10;
    }
    return ans;
}

class Solution {
public:
    int countDigitOne(int n) {
        unsigned i = 1, ans = 0, befor = 0; //i表示记录到了第几位，ans是总和，befor身后的数字
        while(n){
            int tmp = n % 10;  //记录这个位置是什么
            n /= 10;    //n此时是这个位置前面的数字
            if(tmp > 1) ans += (n + 1) * i; //如果这个位置大于1，前面的位置有n+1种取法
            else if(tmp == 1) ans += n * i + befor + 1; //等于1，前面的位置有n+1种取法，
            else ans += n * i;  //这个位置是0，则只有n种取法
            befor += tmp * i;  //记录身后的数字
            i *= 10;   //往下一位
        }
        return ans;
    }
};