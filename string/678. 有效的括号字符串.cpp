/*
678. 有效的括号字符串
给定一个只包含三种字符的字符串：（ ，） 和 *，写一个函数来检验这个字符串是否为有效字符串。有效字符串具有如下规则：

任何左括号 ( 必须有相应的右括号 )。
任何右括号 ) 必须有相应的左括号 ( 。
左括号 ( 必须在对应的右括号之前 )。
* 可以被视为单个右括号 ) ，或单个左括号 ( ，或一个空字符串。
一个空字符串也被视为有效字符串。
示例 1:

输入: "()"
输出: True
示例 2:

输入: "(*)"
输出: True
示例 3:

输入: "(*))"
输出: True
注意:

字符串大小将在 [1，100] 范围内。
*/

/*
 解题思路：
        遍历两次，第一次顺序，第二次逆序。
        第一次遇到左括号加一，右括号减一，星号加一，最后保证cnt >= 0,也就是可以保证产生的左括号足够
        第二次遇到右括号加一，左括号减一，星号加一，最后保证cnt >= 0,也就是可以保证产生的右括号足够
        当两次遍历都是True，那么说明有效.
        
        首先必要性是显然的，如果某个方向不能满足足够的括号，那肯定不有效；而充分性，我们关注的其实是对于*的处理这里，我们这样判断之后其实需要能够对应一个有效的'*'的转换方案，就可以说这个判断是充分的。
        对于有效的*的转换方案，我们在两次遍历中分别将'*'看作'('和')'，那么其实只要两次遍历用于匹配的那些'*'是不相同的集合即可。
        具体一点，我们假设我们的匹配方案是尽可能的先匹配最近的()，在没有可用的情况下再去利用*变换出来的括号
        对于第一次遍历，我们将'*'看作'('，那么最后'('的数量>=')'的数量。最后能够匹配到所有的)，可能会剩余一些'('或者'*'。 那么匹配到的')'有两种，一种直接和最近的'('匹配的')'，一种是和'*'匹配的')‘，我们将第一种的字符对集合记为A，第二个记为B同样，
        对于第二次遍历，我们将'*'看作')'，最后所有'('都会被匹配，同样划分为两种，一种是和最近的')'匹配的，一种是和'*'匹配的，第一种匹配集合记为C，第二种记为D。
        这样，我们发现两次遍历后，所有的'('和')'都至少出现在A,B,C,D，中的一个集合中；简单思考，我们不难发现，A和C是相同的，因为我们的规则总会先去匹配到最近的括号。
        而B和D中的'*'一定是不同的'*'，这个就是我们证明的目标！因为如果B和D中某个'*'是相同位置的'*'的话，那么这个'*'在两次遍历中分别匹配了')'和'('，那么其实这个'*'一定在一对'('和')'之间，而这两个'('其实')'其实本身应该优先相互匹配，出现在集合A(也就是C)中，而不应该属于B和D中。
        由此推出矛盾，于是我们知道C和D中的'*'是不重合的。
        这样我们就得到了一个充分的转换方案，将B中的'*’转换为'('，D中的'*'转换为')'，剩余的没在B和D中的看做空，就能够得到一个有效的括号序列。所以这个两次遍历的判断条件是充分的。
        */

class Solution
{
public:
    bool checkValidString(string s)
    {
        int len = s.size();
        int leftCount = 0;
        int rightCount = 0;
        for (int i = 0, j = len - 1; i < len; ++i, --j)
        {
            if (s[i] == ')') {
                leftCount -= 1;
            } else {
                leftCount += 1;
            }
            if (leftCount < 0) {
                return false;
            }

            if (s[j] == '(') {
                rightCount -= 1;
            } else {
                rightCount += 1;
            }
            if (rightCount < 0) {
                return false;
            }
        }
        return true;
    }
};