#include<iostream>
#include <string>
using namespace std;

/*
判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

示例 1:

输入: 121
输出: true
示例 2:

输入: -121
输出: false
解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
示例 3:

输入: 10
输出: false
解释: 从右向左读, 为 01 。因此它不是一个回文数。

*/

/*--------------------------------------------------------------*/
/*							思路								*/	
/*--------------------------------------------------------------*/
/*
第一个：
	将数字本身进行反转，然后将反转后的数字与原始数字进行比较，如果他们相同，那么这个数字就是回文。
	但是反转后的数字可能大于INT_MAX，我们将遇到整数溢出的问题。
第二个：
	为了避免溢出问题，为什么不考虑只反转int数字的一半？
	毕竟，如果数字是回文，其后一半反转后该与原始数字的前半部分相同。

	例如：输入“1221”，我们可以将数字“1221”的后半部分“21”反转成“12”，并将其于前半部分“12”进行比较，因为二者相同，我们得知1221是回文。

算法：

	首先，我们应该处理一些临界情况。所有负数都不可能是回文，例如：-123不是。所以我们返回false
	现在，我们考虑如何反转后半部分的数字。
	对于数字1221，
	如果执行1221%10，我们将得到的最后一位数字1，
	要得到倒数第二位数字，我们可以通过除以10把最后一位数字从1221中移除，1221 /10 = 122，在求出上一步结果除以10的余数122%10=2,就得到了倒数第二位数。
	如此反复

	我们如何知道反转数字的位数已经达到原始位数的一半？？

	我们将原始数字除以 10，然后给反转后的数字乘上 10，所以，当原始数字小于反转后的数字时，就意味着我们已经处理了一半位数的数字。



*/


bool isPalindrome(int x) {

	int X = x;
	int value = 0;

	if (X < 0)
	{
		return false;
	}

	if (X % 10 == 0 && X != 0)
	{
		return false;
	}

	while (X > value)
	{
		value = value * 10 + (X % 10);
		X /= 10;
	}

	return (X == value) || (X == value / 10);


}

